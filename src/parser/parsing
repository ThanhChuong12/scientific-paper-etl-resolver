import os
import re
import json
import hashlib
import shutil
import logging
import traceback
from concurrent.futures import ProcessPoolExecutor, as_completed

from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any, Set
from dataclasses import dataclass, field
from collections import defaultdict
from difflib import SequenceMatcher

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# ================ CONSTANTS AND CONFIGURATIONS ================
# LaTeX SECTION HIERARCHY
# Defines the logical depth of LaTeX sectioning commands.
SECTION_HIERARCHY = {
    'part': 0,
    'chapter': 1,
    'abstract': 1,
    'section': 2,    
    'subsection': 3,
    'subsubsection': 4,
    'paragraph': 5,
    'subparagraph': 6
}

# FORMATTING-ONLY COMMANDS
# These commands carry no semantic meaning and can be safely removed
FORMATTING_COMMANDS = [
    r'\\centering',
    r'\\raggedright',
    r'\\raggedleft',
    r'\\noindent',
    r'\\small',
    r'\\footnotesize',
    r'\\scriptsize',
    r'\\tiny',
    r'\\normalsize',
    r'\\large',
    r'\\Large',
    r'\\LARGE',
    r'\\huge',
    r'\\Huge',
    r'\\toprule',
    r'\\midrule',
    r'\\bottomrule',
    r'\\hline',
    r'\\cline\{[^}]*\}',
    r'\\newpage',
    r'\\clearpage',
    r'\\pagebreak',
    r'\\linebreak',
    r'\\hfill',
    r'\\vfill',
    r'\\hspace\*?\{[^}]*\}',
    r'\\vspace\*?\{[^}]*\}',
    r'\\bigskip',
    r'\\medskip',
    r'\\smallskip',
    r'\\par\b',
    r'\\indent',
    r'\\setlength\{[^}]*\}\{[^}]*\}',
    r'\\addtolength\{[^}]*\}\{[^}]*\}',
    r'\\label\{[^}]*\}',
]

# TEXT FORMATTING COMMANDS (CONTENT PRESERVING)
TEXT_FORMAT_COMMANDS = [
    (r'\\textbf\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', r'\1'),
    (r'\\textit\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', r'\1'),
    (r'\\emph\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', r'\1'),
    (r'\\underline\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', r'\1'),
    (r'\\texttt\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', r'\1'),
    (r'\\textsf\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', r'\1'),
    (r'\\textrm\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', r'\1'),
    (r'\\textsc\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', r'\1'),
    (r'\\textnormal\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', r'\1'),
    (r'\\mbox\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}', r'\1'),
]

# NODE TYPE PREFIXES
TYPE_PREFIXES = {
    'root': 'doc_root',
    'part': 'part',
    'chapter': 'chapter',
    'section': 'section',
    'subsection': 'subsection',
    'subsubsection': 'subsubsection',
    'paragraph': 'paragraph',
    'subparagraph': 'subparagraph',
    'abstract': 'abstract',
    'itemize': 'itemize',
    'enumerate': 'enumerate',
    'item': 'item',
    'equation': 'eq',
    'figure': 'fig',
    'table': 'fig',
    'sentence': 'sent'
}

# NON-TERMINATING ABBREVIATIONS
# Abbreviations that should not be interpreted as sentence boundaries.
ABBREVIATIONS = [
    r'Fig\.', r'Figs\.', r'Eq\.', r'Eqs\.', r'Sec\.', r'Secs\.', 
    r'Ch\.', r'Tab\.', r'Ref\.', r'Refs\.', r'al\.', r'et al\.',
    r'i\.e\.', r'e\.g\.', r'vs\.', r'etc\.', r'cf\.', r'viz\.',
    r'Dr\.', r'Mr\.', r'Mrs\.', r'Ms\.', r'Prof\.', r'Jr\.', r'Sr\.',
    r'No\.', r'Vol\.', r'pp\.', r'ed\.', r'eds\.'
]

# Citation command pattern (handles \cite variants and \nocite)
CITE_COMMAND_PATTERN = re.compile(
    r'\\(?:[A-Za-z]*cite[a-zA-Z]*|nocite)\*?(?:\[[^\]]*\])*?\s*\{([^}]*)\}',
    re.DOTALL
)

# Files larger than this threshold (in bytes) are parsed with a streaming parser
LARGE_BIB_THRESHOLD_BYTES = 5 * 1024 * 1024  # 5 MB

# ================ DATA CLASSES ================
@dataclass
class HierarchyNode:
    """Represents a node in the document hierarchy."""
    id: str
    content: str
    node_type: str
    level: int
    parent_id: Optional[str] = None
    children: List[str] = field(default_factory=list)
    
    
@dataclass
class BibEntry:
    """Represents a bibliography entry."""
    key: str
    entry_type: str
    fields: Dict[str, str] = field(default_factory=dict)
    raw_content: str = ""
    content_hash: str = ""
